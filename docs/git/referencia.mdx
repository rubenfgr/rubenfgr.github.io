---
title: "Referencia"
sidebar_position: 1
---

## DASH Y DOBLE DASH (- / --)

```sh
- Una sola letra
-- Una palabr
```

## BUENAS PRÁCTICAS

- **Realizar un fetch o pull antes de un push al repositorio**

## CONFIGURACIÓN

- **Configurar el usuario**

```sh
git config --global user.name "RubenFGR"

git config --global user.email "rubenfgr87@outlook.com"
```

- **Editar estos parámetros desde el archivo**

```sh
git config --global -e
```

- **Listar la configuración**

```sh
git config -l
```

## AUTO-IDENTIFICACIÓN

- **Evitar que git solicite el usuario y contraseña cada vez**

```sh
git config --global credential.helper store
```

- **Lo mismo que el anterior mantendiendolo en memoria un tiempo limitado por seguridad**

```sh
git config --global credential.helper 'cache --timeout=3600'
```

- **Eliminar esta configuración**

```sh
sudo rm ~/.git-credentials
```

## STATUS Y LOG

- **Ver todo el historial de la línea de tiempo**

```sh
git reflog
```

- **Ver los últimos cambios después del último commit**

```sh
git diff
```

- **Ver los cambios en el escenario**

```sh
git diff --staged
```

- **Ver diferencias entre dos ramas**

```sh
git diff "rama-uno" "rama-dos"
```

- **Ver el estado actual del repositorio**

```sh
git status
```

- **ver el estado actual del repositorio en formato corto**

```sh
git status -s
```

- **ver el estado actual del repositorio en formato corto y ramas**

```sh
git status -s -b
```

- **Ver todos los cambios del repositorio (commits)**

```sh
git log
```

- **Ver los commits realizados a una línea (hash corto y mensaje)**

```sh
git log --oneline
```

- **Ver los commits realizados de forma gráfica a una línea y decorados**

```sh
git log --graph --oneline --decorate --all
```

## MODIFICACIÓN Y ELIMINACIÓN

- **Modificar el nombre de algún archivo**

```sh
git mv "nombreArchivoAntiguo" "nombreArchivoNuevo"
```

- **Eliminar un archivo**

```sh
git rm "nombreArchivo"
```

## IGNORAR ARCHIVOS Y DIRECTORIOS

1. Crear el fichero .gitignore en el raíz
2. Ignorar directorio `.directorio/`
3. Ignorar fichero `.fichero.txt`
4. Ignorar varios por extension `*.txt`

" Ignorar directorios o ficheros que ya estaban rastreados por git

1. Agregar los ficheros o directorios al .gitignore
2. Limpiar toda la cache de rastreo `git rm -r --cached .`
3. Limpiar un fichero o directorio concreto de la cache de rastreo `git rm --cached .fichero.txt`
4. Agregar los cambios al escenario `git add .`
5. Subir los cambios `git push origin "rama"`

## STAGGING

- **Agrega todos los archivos modificados al escenario**

```sh
git add .

git add --all

git add -- .
```

- **Agregar los archivos dentro de la carpeta al escenario**

```sh
git add carpeta/
```

- **Agregar todos los archivos del directorio actual .png**

```sh
git add \*.png

git add carpeta/\*.pdf
```

- **Agrega todo jerarquicamente al escenario**

```sh
git add -A
```

- **Agregar todos los archivo .txt del proyecto al escenario**

```sh
git add "\*.txt"
```

- **Agregar la lista de archivo al escenario**

```sh
git add "lista de archivos"
```

- **Agregar todo con actualización (-u (update))**

```sh
git add -u
```

- **Eliminar del escenario**

```sh
git reset "nombreFichero | nombreCarpeta"

git reset HEAD "nombreFichero"
```

## COMMIT

- **Los commits se pueden referenciar en GitHub a través de su Hash**
  - HEAD apunta al último commit realizado
  - HEAD^ apunta al penúltimo commit realizado
- **Agregar archivos al escenario y realizar el commit**

```sh
git commit -am "mensaje"
```

- **Modificar el último commit y cambiar el mensaje**

```sh
git commit --amend -m "nuevo mensaje"
```

- **Deshacer un commit sin borrar los archivos (sólo último commit), reset tiene 3 niveles de borrado, el siguiente es el más debil**

```sh
git reset --soft HEAD~1
```

- **Moverse a un punto de la historia (commit) con su hash guardando los cambios superiores**

```sh
git reset --mixed "hash"
```

- **Moverse a un commit con eliminando todo lo superior a el**

```sh
git reset --hard "hash"
```

- **Vuelve el estado del repositorio al último commit**

```sh
git checkout -- .
```

- **Vuelve un archivo al estado que tenia en el último commit**

```sh
git checkout -- "nombre-archivo"
```

- **Vuelve un archivo a su estado en un commit específico**

```sh
git checkout "id-commit" "nombre-archivo"
```

## REMOTO

- **Agregar un repositorio remoto en la ubicación actual**

```sh
git remote add origin "url-repositorio"
```

- **Ver cambios de un repositorio principal sin ser colaboradores**

```sh
git remote add upstream "repo original"

git fetch upstream
```

- **Revisar las fuentes remotas agregadas al repositorio, los repositorios remotos para push y fetch pueden ser distintos**

```sh
git remote -v
```

- **Clonar el repositorio en el directorio actual**

```sh
git clone "url-repositorio"
```

- **Clonar y poner nombre al directorio**

```sh
git clone "url-repositorio" "nombre-repositorio"
```

- **Subir los cambios a remoto**

```sh
git push origin master
```

- **Enviar cambios al repositorio remoto, -u Ayuda a que la próxima vez que queramos hacer push NO necesitemos especificar la rama**

```sh
git push -u origin master
```

## BRANCHS

- **Ver las ramas actuales**

```sh
git branch
```

- **Ver todas las ramas, incluidas las remotas**

```sh
git branch -a
```

- **Agregar una rama nueva**

```sh
git branch "nombre-rama"
```

- **Cambiar de rama**

```sh
git checkout "nombre-rama"
```

- **Cambiar de rama creandola porque no existe**

```sh
git checkout -b "nombre-rama-nueva"
```

- **Fusionar ramas integrando codigo de una rama dentro de otra, colocarse en la rama donde se desean fusionar los cambios**

```sh
git merge "nombre-rama-a-fusionar"
```

- **Limpiar ramas que ya están funsionadas y no sirven para nada**

```sh
git branch -d "nombre-rama"
```

- **El -d no siempre funciona ya que comprueba que no siempre vallas a perder trabajo, es decir, que los commit de la rama a eliminar estén en master. Para obligar el borrado de la rama se utiliza -D (en mayúscula)**

```sh
git branch -D "nombre-rama"
```

- **Eliminar una rama remota despues de comprobar con branch -a**

```sh
git push origin :"nombre-rama"
```

- **Eliminar ramas de seguimiento remoto obsoletas en "nombre"**

```sh
git remote prune "nombre-remoto"

git remote prune "nombre-remoto" --dry-run (no las elimina)
```

- **Realmente, los commit que había en esa rama no se eliminan. Git usa un recolector de basura de vez en cuando para borrar commits antiguos. En caso de borrar archivos binarios muy grandes será necesario llamar al gc de git explícitamente con**

```sh
git gc
```

## TAG & RELEASE

- **Crear un tag**

```sh
git tag "nombre-tag"
```

- **Crear un tag con anotación de versión + mensaje**

```sh
git tag -a v1.0.0 -m "Versión 1.0.0"
```

- **Crear un tag sobre un commit a través de su hash**

```sh
git tag -a v.0.1.0 "hash-commit" -m "Mensaje a mostrar"
```

- **Crear un tag más elaborado**

```sh
git tag -a "version" "hash-commit"
```

- **Ver los tag del repositorio**

```sh
git tag
```

- **Eliminar un tag**

```sh
git tag -d "nombre-tag"
```

- **Ver información de un tag específico**

```sh
git show "tag"
```

- **Subir los tags al repositorio**

```sh
git push --tags
```

## VERSIONADO

- v1.0.0
- Mayor.Menor.Parche
- Más información acerca del versionado: [semver.org](https://semver.org/)

## ISSUES

- **Cerrar un Issue con un commit (fixes, closes, resolves)**

```sh
git commit -am "mensaje..." "fixes|closes|resolves #num-issue"
```

## STASH [WIP - Working In Progress]

El stash se utiliza para guardar el trabajo actual en el tiempo y poder volver a el # en cualquier momento

```sh
git stash

git stash sav

git stash save "mensaje a mostrar"
```

- **Ver todos los trabajos en progreso que hay**

```sh
git stash list
```

- **Igual a la anterior con más información**

```sh
git stash list -a
```

- **Ver información del último stash realizado (cambios realizados en archivos)**

```sh
git show stash
```

- **Ver informaciónd e un stash en concreto**

```sh
git show stash@{0}
```

- **Recuperar el último ingreso del stash y eliminarlo al mismo tiempo**

```sh
git stash pop
```

- **Recuperar el último ingreso del stash**

```sh
git stash apply
```

- **Recuperar un stash por su ID**

```sh
git stash apply "ID-stash" ES EQUIVALENTE A git stash apply stash@{0}
```

Ejemplo: `git stash apply stash@{1}`

- **Eliminar el último stash realizado**

```sh
git stash drop ES EQUIVALENTE A git stash drop stash@{0}

git stash drop "ID-stash"
```

- **Guardar todo menos los archivos en el stage (escenario)**

```sh
git stash save --keep-index
```

- **Incluye todos los archivos junto a los que git no le da seguimiento ()**

```sh
git stash save --include-untracked
```

- **Borrar todas las entradas del stash sin recuperación**

```sh
git stash clear
```

## REBASE

- **Traer commits de otra rama a la actual y rebasarlos**

```sh
git rebase "nombre-rama"
```

- **Rebase interactivo: ordenar commits, corregir mensajes de estos, unirlos o separarlos**

```sh
git rebase -i HEAD~"numero-de-commits"
```

- **Opciones del comando anterior**

**squash** = une el commit donde es utilizado con el anterior

**reward** = cambiar el mensaje del commit

**edit** = editar uno o más commits (Ej: separar archivos)

- **En caso de separar un commit en dos sera necesario dar un salto atrás**

```sh
git reset HEAD^
```

1. Agregar uno de los archivos al stage y realizar el commit
2. Agregar los demás archivos y realizar los commits deseados
3. Continuar el rebase con:

```sh
git rebase --continue
```

## GIT CHERRY-PICK

Se trae un commit por su referencia a tu posición actual. Seguidamente un ejemplo de uso.

```sh title="historial de commit ANTES"
* 2604d8c (HEAD -> cherry-pick) updated git reference
* 6ce1d6d (HEAD -> main, origin/main) mensaje del último commit
* 77a44e6 mensaje del commit
* a6bf360 mensaje del commit
* 6ddbe70 mensaje del commit
* 87aeea1 mensaje del commit
* 87aeea1 mensaje del commit
```

Nos movemos a main y hacemos un cherry-pick al último commit de la rama "cherry-pick"

```sh
git checkout main

git cherry-pick 2604d8c
```

## COMANDOS ÚTILES

- **Buscar una cadena en todo el ábol de contenido**

```sh
git grep ""palabra o frase a buscar""
```

- **Interfaz gráfica para un repositorio local**

```sh
sudo apt-get install gitk

gitk
```

- **Ver objeto de árbol junto con el nombre y modo de cada uno, y el valor blob SHA-1**

```sh
git ls-tree "hash-commit"
```

- **Usando el valor SHA-1 se puede ver el tipo de objeto**

```sh
git cat-file -p "valor-SHA-1"
```

- **Crear archivo zip o tar de un árbol del repositorio**

```sh
git archive -- -format=tar master
```

- **Chequeo de integridad del sistema de archivos de git. Detecta cualquier objeto corrompido**

```sh
git fsck
```

## ALIAS

```sh
git config --global alias.lg "log --oneline --decorate --all --graph"
```

```sh
git config --global alias.s "status -s -b"
```

## SSH

- **Entrar en el directorio de usuario**

```sh
cd user-name/.ssh
```

- **Crear las claves ssh para GitHub**

```sh
ssh-keygen -t rsa -C "direccion@de.correo"
```

- **Registrar GitHub para SSH**

```sh
  ssh -T git@github.com
```

## ERRORES COMUNES

- **Agregando todos los archivos al escenario**

```sh
git add -A
```

warning: LF will be replaced by CRLF in "rutaArchivo"

The file will have its orginal line endings in your working directory

**Solución:**

```sh
git config core.autocrlf true
```
